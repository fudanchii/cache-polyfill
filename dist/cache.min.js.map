{"version":3,"file":"cache.min.js","sources":["../src/cache.js","../src/cache-storage.js"],"sourcesContent":["const map = new WeakMap()\nconst wm = o => map.get(o)\n\nconst requires = (i, args) => {\n  if (args.length < i) {\n    throw new TypeError(`${i} argument required, but only ${args.length} present.`)\n  }\n}\n\nconst isReq = req => req && req instanceof Request\n\nfunction openDB () {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = () => {\n      const db = open.result\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      const cacheStore = db.createObjectStore('caches', { autoIncrement: true })\n      cacheStore.createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result)\n    }\n  })\n}\n\nclass Cache {\n  constructor (cacheName) {\n    map.set(this, cacheName)\n  }\n\n  /**\n   * Returns a Promise that resolves to the response associated\n   * with the first matching request in the Cache object.\n   *\n   * @param  {[type]}  args [description]\n   * @return {Promise}      [description]\n   */\n  async match (...args) {\n    return (await this.matchAll(...args))[0]\n  }\n\n  // Returns a Promise that resolves to an array\n  // of all matching requests in the Cache object.\n  async matchAll (req, options = {}) {\n    if (req.method === 'HEAD') return []\n\n    const cacheName = wm(this)\n    const db = await openDB()\n    const result = []\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readonly')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.openCursor(IDBKeyRange.only(cacheName))\n    request.onsuccess = function () {\n      const cursor = this.result\n\n      if (cursor) {\n        if ((req.url || req) === cursor.value.reqUrl) {\n          const initData = Object.assign({\n            url: cursor.value.resUrl\n          }, cursor.value)\n\n          const res = new Response(cursor.value.body, initData)\n          result.push(res)\n        }\n        cursor.continue()\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(result)\n    )\n  }\n\n  // Takes a URL, retrieves it and adds the resulting response\n  // object to the given cache. This is fuctionally equivalent\n  // to calling fetch(), then using put() to add the results to the cache\n  async add (request) {\n    requires(1, arguments)\n    return this.addAll([request])\n  }\n\n  // Takes an array of URLs, retrieves them, and adds the\n  // resulting response objects to the given cache.\n  async addAll (requests) {\n    requires(1, arguments)\n\n    let results = []\n\n    for (let req of requests) {\n      req = new Request(req)\n\n      if (!/^((http|https):\\/\\/)/.test(req.url)) {\n        throw new TypeError(`Add/AddAll does not support schemes other than \"http\" or \"https\"`)\n      }\n\n      if (req.method !== 'GET') {\n        throw new TypeError(`Add/AddAll only supports the GET request method`)\n      }\n\n      const clone = req.clone()\n\n      await fetch(clone).then(res => {\n        if (res.status === 206) {\n          throw new TypeError('Partial response (status code 206) is unsupported')\n        }\n\n        if (!res.ok) {\n          throw new TypeError('Request failed')\n        }\n\n        results.push([req, res])\n      })\n    }\n\n    await Promise.all(results.map(a => this.put(...a)))\n  }\n\n  /**\n   * Takes both a request and its response and adds it to the given cache.\n   *\n   * @param  {Request|String}  req  [description]\n   * @param  {Response}        res  [description]\n   * @return {Promise}              [description]\n   */\n  async put (req, res) {\n    requires(2, arguments)\n\n    req = isReq(req) ? req : new Request(req)\n\n    await this.delete(req)\n\n    if (!/^((http|https):\\/\\/)/.test(req.url)) {\n      throw new TypeError(`Request scheme '${req.url.split(':')[0]}' is unsupported`)\n    }\n\n    if (req.method !== 'GET') {\n      throw new TypeError(`Request method '${req.method}' is unsupported`)\n    }\n\n    if (res.status === 206) {\n      throw new TypeError('Partial response (status code 206) is unsupported')\n    }\n\n    let varyHeaders = res.headers.get('Vary')\n\n    if (varyHeaders && varyHeaders.includes('*')) {\n      throw new TypeError('Vary header contains *')\n    }\n\n    if (res.body != null && res.bodyUsed) {\n      throw new TypeError('Response body is already used')\n    }\n\n    let folder = wm(this)\n    let cache = {\n      cacheName: folder,\n      headers: [...res.headers.entries()],\n      status: res.status,\n      statusText: res.statusText,\n      body: await res.arrayBuffer(),\n      reqUrl: req.url.replace(/#.*$/, ''),\n      resUrl: res.url.replace(/#.*$/, ''),\n      reqMethod: req.method\n    }\n\n    const db = await openDB()\n\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('caches', 'readwrite')\n      const store = tx.objectStore('caches')\n\n      // Add some data\n      store.put(cache)\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(tx.error)\n    })\n  }\n\n  // Finds the Cache entry whose key is the request, and if found,\n  // deletes the Cache entry and returns a Promise that resolves to true.\n  // If no Cache entry is found, it returns false.\n  async delete (request, options = {}) {\n    requires(1, arguments)\n    const cacheName = wm(this)\n\n    const { ignoreMethod } = options\n    const r = isReq(request) ? request : new Request(request)\n\n    if (!['GET', 'HEAD'].includes(r.method) && ignoreMethod) {\n      return false\n    }\n\n    const { method } = r\n    const url = r.url.replace(/#.*$/, '')\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction('caches', 'readwrite')\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const query = index.openCursor(IDBKeyRange.only(cacheName))\n\n    let deleted = false\n\n    query.onsuccess = function () {\n      const cursor = this.result\n\n      if (cursor) {\n        if (url === cursor.value.reqUrl && (ignoreMethod || method === cursor.value.reqMethod)) {\n          deleted = true\n          caches.delete(cursor.primaryKey)\n        }\n        cursor.continue()\n      }\n    }\n\n    return new Promise(rs =>\n      tx.oncomplete = () => rs(deleted)\n    )\n  }\n\n  // Returns a Promise that resolves to an array of Cache keys.\n  async keys (request, options = {}) {\n    let url\n    const folder = wm(this)\n    const {\n      ignoreMethod = false,\n      ignoreSearch = false\n    } = options\n\n    // using new Request to normalize fragment and trailing slash\n    if (request !== undefined) {\n      request = new Request(request)\n\n      url = request.url.split('#')[0]\n\n      if (request.method !== 'GET' && !ignoreMethod) return []\n    }\n\n    const search = request === undefined ? a => a : a => a.filter(a => {\n      if (ignoreSearch) {\n        a = a.reqUrl.split('?')[0]\n        url = url.split('?')[0]\n      } else {\n        a = a.reqUrl\n      }\n\n      return a === url\n    })\n\n    const db = await openDB()\n\n    const responses = await new Promise(rs => {\n      const tx = db.transaction('caches', 'readonly')\n      const store = tx.objectStore('caches')\n      const cacheName = store.index('cacheName')\n      const request = cacheName.getAll(IDBKeyRange.only(folder))\n      request.onsuccess = () => rs(request.result)\n    })\n\n    return search(responses).map(response => new Request(response.reqUrl))\n  }\n}\n\nmodule.exports = Cache\n","const Cache = require('./cache')\n\nfunction openDB () {\n  return new Promise(rs => {\n    // Open (or create) the database\n    const open = indexedDB.open('cachestorage', 4)\n    // Create the schema\n    open.onupgradeneeded = function () {\n      const db = open.result\n      // cointains all storage containsers\n      db.createObjectStore('storages', { keyPath: 'cacheName' })\n      // contains all cache of request and responses\n      db.createObjectStore('caches', { autoIncrement: true })\n        .createIndex('cacheName', 'cacheName', { unique: false })\n    }\n\n    open.onsuccess = () => {\n      // Start a new transaction\n      rs(open.result)\n    }\n  })\n}\n\nclass CacheStorage {\n  /**\n   * [delete description]\n   * @return {[type]} [description]\n   */\n  async delete (cacheName) {\n    // Should resolve to false if there is nothing to delete\n    const keys = await this.keys()\n\n    if (!keys.includes(cacheName)) {\n      return false\n    }\n\n    const db = await openDB()\n\n    // Start a new transaction\n    const tx = db.transaction(['storages', 'caches'], 'readwrite')\n    tx.objectStore('storages').delete(cacheName)\n\n    const caches = tx.objectStore('caches')\n    const index = caches.index('cacheName')\n    const request = index.getAllKeys(IDBKeyRange.only(cacheName))\n\n    request.onsuccess = function (tx) {\n      for (let key of this.result) {\n        caches.delete(key)\n      }\n    }\n\n    return new Promise((rs, rj) => {\n      tx.oncomplete = () => rs(true)\n      tx.onerror = () => rj(false)\n    })\n  }\n\n  /**\n   * [has description]\n   * @return {Boolean} [description]\n   */\n  has (cacheName) {\n    return this.keys().then(keys => keys.includes(cacheName))\n  }\n\n  /**\n   * resolves with an array containing strings corresponding to all of the named\n   * Cache objects tracked by the CacheStorage.\n   * Use this method to iterate over a list of all the Cache objects.\n   *\n   * @return <Promise>Array keyList\n   */\n  async keys () {\n    const db = await openDB()\n\n    // Start a new transaction\n    const keys = db.transaction('storages', 'readonly').objectStore('storages').getAllKeys()\n\n    return new Promise(rs =>\n      keys.onsuccess = () => rs(keys.result)\n    )\n  }\n\n  /**\n   * Checks if a given Request is a key in any of the Cache objects\n   * that the CacheStorage object tracks and returns a Promise that\n   * resolves to that match.\n   *\n   * @return Promise\n   */\n  async match (...args) {\n    let keys = await this.keys()\n\n    for (let key of keys) {\n      let cache = await this.open(key)\n      let result = await cache.match(...args)\n      if (result) return result\n    }\n  }\n\n  /**\n   * Resolves to the Cache object matching the cacheName\n   * (a new cache is created if it doesn't exist.)\n   *\n   * @return {[type]} [description]\n   */\n  async open (cacheName) {\n    if (arguments.length < 1) {\n      throw new TypeError(`${arguments.length} argument required, but only ${arguments.length} present.`)\n    }\n\n    const db = await openDB()\n    await new Promise((rs, rj) => {\n      const tx = db.transaction('storages', 'readwrite')\n      const store = tx.objectStore('storages')\n\n      // Add some data\n      store.put({ cacheName })\n\n      tx.oncomplete = () => rs()\n      tx.onerror = () => rj(tx.error)\n    })\n\n    return new Cache(cacheName)\n  }\n\n  /**\n   * [description]\n   * @return {[type]} [description]\n   */\n  [Symbol.toStringTag] () {\n    return 'CacheStorage'\n  }\n}\n\nmodule.exports = {\n  Cache,\n  CacheStorage,\n  caches: window.caches || new CacheStorage(),\n}\n"],"names":["map","WeakMap","wm","o","get","requires","i","args","length","TypeError","isReq","req","Request","openDB","Promise","rs","open","indexedDB","onupgradeneeded","db","result","createObjectStore","keyPath","autoIncrement","createIndex","unique","onsuccess","cacheName","set","this","async","matchAll","method","tx","transaction","objectStore","index","openCursor","IDBKeyRange","only","cursor","url","value","reqUrl","initData","Object","assign","resUrl","res","Response","body","push","oncomplete","request","arguments","addAll","requests","results","test","clone","fetch","then","status","ok","all","a","_this","put","split","varyHeaders","headers","includes","bodyUsed","folder","cache","entries","statusText","arrayBuffer","replace","reqMethod","rj","onerror","error","options","ignoreMethod","r","caches","query","deleted","primaryKey","ignoreSearch","undefined","search","filter","responses","getAll","response","CacheStorage","keys","getAllKeys","key","match","Cache","Symbol","toStringTag","window"],"mappings":"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"}